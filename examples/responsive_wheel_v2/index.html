<!--
    *** NOTE: UNDER CONSTRUCTION ***

    +++ VERSION 2 - with a scaling factor on all calculations +++

    Winhweel.js responsive wheel example by Douglas McKechie @ www.dougtesting.net
    See website for tutorials and other documentation.

    The MIT License (MIT)

    Copyright (c) 2018 Douglas McKechie

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
-->
<html>
    <head>
        <title>HTML5 Canvas Winning Wheel</title>
        <link rel="stylesheet" href="main.css" type="text/css" />
        <script type="text/javascript" src="ResponsiveWinwheel.js"></script>
        <script src="http://cdnjs.cloudflare.com/ajax/libs/gsap/latest/TweenMax.min.js"></script>
    </head>
    <!-- Add handlers for the onLoad and onResize events -->
    <body>
        <div align="center">
            <h1>Winwheel.js - responsive wheel example</h1>
            <p>Here is an example of a responsive Winwheel.js which re-sizes to fit the window / device viewed on.</p>
            <br />
            <p>
                This can be achieved by setting a few parameters on the wheel. The key part of this is the scaleFactor
                is used to reduce the size of the wheel from the original values which as considered the max.
            </p>
            <br />
            <!-- Set canvas to largest desired size - i.e. the desktop size - for tablets and mobile we will make it smaller -->
            <canvas id="canvas" width="500" height="500" style="background-color: silver" data-responsiveMinWidth="200" data-responsiveMargin="30" data-responsiveScaleHeight="true">
                <p style="{color: white}" align="center">Sorry, your browser doesn't support canvas. Please try another.</p>
            </canvas>
            <br /><br />
            <p align="center">Tap the wheel to begin spinning.</p>
        </div>
        <script>
            // Define some variables to be used in the responisve calculations.
            let maxWidth = 500;     // Maximum canvas width - note set to the same as the width of the canvas above.
            let minWidth = 250;     // Minimum canvas width we will allow.
            let margin = 30;
            let theCanvas = document.getElementById('canvas');

            /*
            // -----------------------------------------------------------------
            // This function is called by the onLoad and onResize events of the window
            // and takes care of adjusting the canvas size and winwheel properties.
            function resizeCanvas_Code() {
                // Get the width of the window excluding any toolbars etc.
                let width = window.innerWidth;

                if (width < minWidth) {
                    width = minWidth;
                } else if (width > maxWidth) {
                    width = maxWidth;
                }

                // Call function to re-size the things we want no matter the drawMode.
                resizeCanvas_Common(width);

                // Redraw the wheel so any changes appear.
                theWheel.draw();

                //++ Think we need to provide some built in responsiveness for the 95% of people who will not be altering
                //++ the wheel after it is created other than animating it (they can change non size properties). TO make it
                //++ easier then advanced devs will have to code their own function to do this.

                //++ Also need to consider what is segments have their own fontSize as if set on the segment thn global values
                //++ for the font and margin are not used. Perhaps make it so the auto function will only work for global values.

                //++ OK so now for single image, what is the best way to sort that?
            }

            // -----------------------------------------------------------------
            // This function re-sizes a wheel made out of a single image.
            function resizeCanvas_Image()
            {
                // Get the width of the window excluding any toolbars etc.
                let width = window.innerWidth;

                if (width < minWidth) {
                    width = minWidth;
                } else if (width > maxWidth) {
                    width = maxWidth;
                }

                // Ok so the same thing no matter the drawMode is re-sizing the canvas.
                resizeCanvas_Common(width);

                // Now we need to scale the image. I think the canvas function to draw images can actually
                // do this at time of drawing so perhaps a small change to the Winwheel.js is desired?
                // For now actually do the drawing here.
                let percent = (width / maxWidth);

                let widthPercent = (theWheel.wheelImage.width * percent);
                let heightPercent = (theWheel.wheelImage.height * percent);

                var imageLeft = theWheel.centerX - (widthPercent / 2);
                var imageTop  = theWheel.centerY - (heightPercent / 2);

                // Rotate and then draw the wheel.
                // We must rotate by the rotationAngle before drawing to ensure that image wheels will spin.
                theWheel.ctx.save();
                theWheel.ctx.translate(theWheel.centerX, theWheel.centerY);
                theWheel.ctx.rotate(theWheel.degToRad(theWheel.rotationAngle));
                theWheel.ctx.translate(-theWheel.centerX, -theWheel.centerY);

                theWheel.ctx.drawImage(theWheel.wheelImage, imageLeft, imageTop, widthPercent, heightPercent);

                theWheel.ctx.restore();

                // Last thing is always to re-draw the wheel on the canvas.
                //theWheel.draw();
            }
            */

            // -----------------------------------------------------------------
            // This function re-sizes segmentImage wheels.
            function resizeCanvas_SegmentImage()
            {
                // Get the width of the window excluding any toolbars etc.
                let width = window.innerWidth;

                if (width < minWidth) {
                    width = minWidth;
                } else if (width > maxWidth) {
                    width = maxWidth;
                }

                // Ok so the same thing no matter the drawMode is re-sizing the canvas.
                resizeCanvas_Common(width);

                // Work out the percent the current width is of the normal max width.
                let percent = (width / maxWidth);

                // Think where each segment is drawn the image needs to scaled at draw time like with single image.
                //++ Again small changes inside the Winwheel.js would be best to support this, but for now a copy of the draw function
                //++ is included here to figure this out.

                // Loop though and output all segments - position 0 of the array is not used, so start loop from index 1
                // this is to avoid confusion when talking about the first segment.
                for (x = 1; x <= theWheel.numSegments; x ++)
                {
                    // Get the segment object as we need it to read options from.
                    seg = theWheel.segments[x];

                    // Check image has loaded so a property such as height has a value.
                    if (seg.imgData.height)
                    {
                        // Work out the correct X and Y to draw the image at which depends on the direction of the image.
                        // Images can be created in 4 directions. North, South, East, West.
                        // North: Outside at top, inside at bottom. Sits evenly over the 0 degrees angle.
                        // South: Outside at bottom, inside at top. Sits evenly over the 180 degrees angle.
                        // East: Outside at right, inside at left. Sits evenly over the 90 degrees angle.
                        // West: Outside at left, inside at right. Sits evenly over the 270 degrees angle.
                        var imageLeft = 0;
                        var imageTop = 0;
                        var imageAngle = 0;
                        var imageDirection = '';

                        //++ Adjust here and use adjusted values below? Yes that is what is required.
                        //++ So it means the image scaling for both segment image and image needs to built in to the wheel
                        //++ and somehow the percent, the divisor needs to passed in to the wheel.
                        //++ Think need event handler function that calls scaleWheel and passes in the width.
                        let widthPercent = (seg.imgData.width * percent);
                        let heightPercent = (seg.imgData.height * percent);

                        if (seg.imageDirection !== null)
                            imageDirection = seg.imageDirection;
                        else
                            imageDirection = this.imageDirection;

                        if (imageDirection == 'S')
                        {
                            // Left set so image sits half/half over the 180 degrees point.
                            imageLeft = (theWheel.centerX - (widthPercent / 2));

                            // Top so image starts at the centerY.
                            imageTop = theWheel.centerY;

                            // Angle to draw the image is its starting angle + half its size.
                            // Here we add 180 to the angle to the segment is poistioned correctly.
                            imageAngle = (seg.startAngle + 180 + ((seg.endAngle - seg.startAngle) / 2));
                        }
                        else if (imageDirection == 'E')
                        {
                            // Left set so image starts and the center point.
                            imageLeft = theWheel.centerX;

                            // Top is so that it sits half/half over the 90 degree point.
                            imageTop  = (theWheel.centerY - (heightPercent / 2));

                            // Again get the angle in the center of the segment and add it to the rotation angle.
                            // this time we need to add 270 to that to the segment is rendered the correct place.
                            imageAngle = (seg.startAngle + 270 + ((seg.endAngle - seg.startAngle) / 2));
                        }
                        else if (imageDirection == 'W')
                        {
                            // Left is the centerX minus the width of the image.
                            imageLeft = (theWheel.centerX - widthPercent);

                            // Top is so that it sits half/half over the 270 degree point.
                            imageTop  = (theWheel.centerY - (heightPercent / 2));

                            // Again get the angle in the center of the segment and add it to the rotation angle.
                            // this time we need to add 90 to that to the segment is rendered the correct place.
                            imageAngle = (seg.startAngle + 90 + ((seg.endAngle - seg.startAngle) / 2));
                        }
                        else // North is the default.
                        {
                            // Left set so image sits half/half over the 0 degrees point.
                            imageLeft = (theWheel.centerX - (widthPercent / 2));

                            // Top so image is its height out (above) the center point.
                            imageTop  = (theWheel.centerY - heightPercent);

                            // Angle to draw the image is its starting angle + half its size.
                            // this sits it half/half over the center angle of the segment.
                            imageAngle = (seg.startAngle + ((seg.endAngle - seg.startAngle) / 2));
                        }

                        // --------------------------------------------------
                        // Rotate to the position of the segment and then draw the image.
                        theWheel.ctx.save();
                        theWheel.ctx.translate(theWheel.centerX, theWheel.centerY);

                        // So math here is the rotation angle of the wheel plus half way between the start and end angle of the segment.
                        theWheel.ctx.rotate(theWheel.degToRad(theWheel.rotationAngle + imageAngle));
                        theWheel.ctx.translate(-theWheel.centerX, -theWheel.centerY);

                        // Draw the image.
                        theWheel.ctx.drawImage(seg.imgData, imageLeft, imageTop, widthPercent, heightPercent);

                        theWheel.ctx.restore();
                    }
                    else
                    {
                        console.log('Segment ' + x + ' imgData is not loaded');
                    }
                }
            }

            // -----------------------------------------------------------------
            // Resizes the common things no matter the drawMode. This actually takes care of all things for the code
            // drawn wheels, only image and segmentImage wheels need extra things done.
            function resizeCanvas_Common(width)
            {
                // Firstly adjust the canvas size. I added a silver background to it
                // so we can more easily see what happens on the page.
                //++ Revisit margin annoyance.
                theCanvas.width = (width - margin);

                // Also because the canvas is square we can set the height to be the same as the width.
                theCanvas.height = (width - margin);

                // Now also we must adjust the outerRadius of the wheel, otherwise even if the canvas shrinks the
                // wheel will stay the same size inside it. We want the wheel to fill the canvas.
                //++ This assumes the wheel is to fill the canvas, if the wheel already has an outerRadius then need to scale it.
                theWheel.outerRadius = (theCanvas.width / 2) - theWheel.lineWidth - margin;

                // And we must adjust the centerX and centerY of the wheel so the center point stays in the middle of the canvas.
                //++ Again if the wheel is off center then need to scale the values rather than just setting to the center.
                theWheel.centerX = theCanvas.width / 2;
                theWheel.centerY = theCanvas.height / 2;

                // Finally adjust the font size so the text in the segments does not break out of them.
                // Find out what percent the width is of the maxWidth and use this to scale the textFontSize down.
                // The 28 is the font-size specified in the wheel config below.
                let percent = (width / maxWidth);
                //++ Need some way to retain the original value and get as can't just hard code the font size.
                //++ Another possible issue is if values are changed after wheel is created if store original values.
                theWheel.textFontSize = (28 * percent);

                // The text margin also needs to be adjusted otherwise at smaller sizes the text no longer looks centered.
                theWheel.textMargin = (theWheel.textFontSize / 1.7);
            }

            // -----------------------------------------------------------------
            // Create winwheel as per normal.
            let theWheel = new Winwheel({
                'numSegments'  : 8,     // Specify number of segments.
                'outerRadius'  : 212,   // Set outer radius so wheel fits inside the background.
                'textFontSize' : 28,    // Set font size as desired.
                'drawMode'     : 'segmentImage',
                'responsive'   : true,  // This wheel is responsive.
                'segments'     :        // Define segments including colour and text.
                [
                   {'fillStyle' : '#eae56f', 'text' : 'Prize 1', 'image': 'jane.png'},
                   {'fillStyle' : '#89f26e', 'text' : 'Prize 2', 'image': 'mary.png'},
                   {'fillStyle' : '#7de6ef', 'text' : 'Prize 3', 'image': 'tom.png'},
                   {'fillStyle' : '#e7706f', 'text' : 'Prize 4', 'image': 'jane.png'},
                   {'fillStyle' : '#eae56f', 'text' : 'Prize 5', 'image': 'mary.png'},
                   {'fillStyle' : '#89f26e', 'text' : 'Prize 6', 'image': 'tom.png'},
                   {'fillStyle' : '#eae56f', 'text' : 'Prize 7', 'image': 'mary.png'},
                   {'fillStyle' : '#89f26e', 'text' : 'Prize 8', 'image': 'tom.png'}
                ],
                'animation' :           // Specify the animation to use.
                {
                    'type'     : 'spinToStop',
                    'duration' : 5,     // Duration in seconds.
                    'spins'    : 8,     // Number of complete spins.
                    'callbackFinished' : alertPrize
                }
            });

            //------------------------------------------------------------------
            // Create new image object in memory.
            /*
            var loadedImg = new Image();

            // Create callback to execute once the image has finished loading.
            loadedImg.onload = function()
            {
                theWheel.wheelImage = loadedImg;    // Make wheelImage equal the loaded image object.
                theWheel.draw();                    // Also call draw function to render the wheel.
            }

            // Set the image source, once complete this will trigger the onLoad callback (above).
            loadedImg.src = "planes.png";
            */

            // -----------------------------------------------------------------
            // Called when the spinning has finished.
            function alertPrize(indicatedSegment)
            {
                // Just do a basic alert of the the prize won.
                alert("You have won " + indicatedSegment.text);
            }
        </script>
    </body>
</html>
